#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
CERTS_DIR="${ROOT_DIR}/.certs"

rm -rf "${CERTS_DIR}"
mkdir -p "${CERTS_DIR}"

WEBHOOK_NAME="${WEBHOOK_NAME:-gitlab-workspaces-kubernetes-webhook}"
WEBHOOK_NAMESPACE="${WEBHOOK_NAMESPACE:-default}"
CLUSTER_DOMAIN="${CLUSTER_DOMAIN:-cluster.local}"   # override if your cluster uses a custom domain

###############################################################################
# 1. Generate a root CA that you will embed in the webhook configuration
###############################################################################
openssl genrsa -out "${CERTS_DIR}/ca.key" 4096
openssl req  -x509 -new -nodes -days 365 \
  -subj "/C=AU/ST=None/L=None/O=GitLab/CN=${WEBHOOK_NAME}-ca" \
  -key  "${CERTS_DIR}/ca.key" \
  -out  "${CERTS_DIR}/ca.crt"

###############################################################################
# 2. Build an OpenSSL config on-the-fly so we can pack in all the SAN entries
###############################################################################
cat > "${CERTS_DIR}/openssl.cnf" <<EOF
[ req ]
default_bits       = 2048
prompt             = no
default_md         = sha256
distinguished_name = dn
req_extensions     = v3_req

[ dn ]
C  = AU
CN = ${WEBHOOK_NAME}

[ v3_req ]
keyUsage               = critical, digitalSignature, keyEncipherment
extendedKeyUsage       = serverAuth, clientAuth
subjectAltName         = @alt_names

[ alt_names ]
DNS.1 = ${WEBHOOK_NAME}
DNS.2 = ${WEBHOOK_NAME}.${WEBHOOK_NAMESPACE}
DNS.3 = ${WEBHOOK_NAME}.${WEBHOOK_NAMESPACE}.svc
DNS.4 = ${WEBHOOK_NAME}.${WEBHOOK_NAMESPACE}.svc.${CLUSTER_DOMAIN}
DNS.5 = *.${WEBHOOK_NAMESPACE}.svc
DNS.6 = *.${WEBHOOK_NAMESPACE}.svc.${CLUSTER_DOMAIN}
EOF

###############################################################################
# 3. Create the server key / CSR and sign it with the CA
###############################################################################
openssl req -new -nodes \
  -keyout "${CERTS_DIR}/server.key" \
  -out    "${CERTS_DIR}/server.csr" \
  -config "${CERTS_DIR}/openssl.cnf"

openssl x509 -req -days 365 \
  -in   "${CERTS_DIR}/server.csr" \
  -CA   "${CERTS_DIR}/ca.crt" \
  -CAkey "${CERTS_DIR}/ca.key" \
  -CAcreateserial \
  -out  "${CERTS_DIR}/server.crt" \
  -extensions v3_req -extfile "${CERTS_DIR}/openssl.cnf"

###############################################################################
# 4. Wrap the key and cert in a Kubernetes TLS secret (dry-run YAML)
###############################################################################
kubectl -n "${WEBHOOK_NAMESPACE}" create secret tls "${WEBHOOK_NAME}-tls" \
  --cert="${CERTS_DIR}/server.crt" \
  --key="${CERTS_DIR}/server.key" \
  --dry-run=client -o yaml \
  > "${SCRIPT_DIR}/manifests/webhook/webhook.tls.secret.yaml"

###############################################################################
# 5. Base64-encode the CA and inject it into the Mutating & Validating configs
###############################################################################
CA_BUNDLE=$(base64 -w0 < "${CERTS_DIR}/ca.crt")
FOLDED_CA=$(echo "$CA_BUNDLE" | fold -w64 | sed 's/^/        /')
ESCAPED_CA=$(printf "%s\n" "$FOLDED_CA" | sed ':a;N;$!ba;s/\n/\\n/g')

for yaml in \
  "${ROOT_DIR}/dev/manifests/cluster-config/mutating.config.yaml" \
  "${ROOT_DIR}/dev/manifests/cluster-config/validating.config.yaml"
do
  echo ">> Injecting CA bundle into $yaml"
  sed -i "s|<CA>|$ESCAPED_CA|" "$yaml"
done

echo "âœ…  Certificates generated and manifests updated"
rm -rf "${CERTS_DIR}"
